# 计算机组成原理第4次作业

<p align="right">by PB18000227 艾语晨</p>
<p align="right">on Apr.14th</p>

### Exercise 4.12

> Q : 

##### In this exercise, we examine how pipelining affects the clock cycle time of the pro- cessor. Problems in this exercise assume that individual stages of the datapath have  the following latencies:

|      | IF    | ID    | EX    | MEM   | WB    |
| ---- | ----- | ----- | ----- | ----- | ----- |
| a.   | 300ps | 400ps | 350ps | 500ps | 100ps |
| b.   | 200ps | 150ps | 120ps | 190ps | 140ps |

> **4.12.1** [5] <4.5> What is the clock cycle time in a pipelined and non-pipelined processor?

> <font color=green>Answer :</font> 
>
> 流水线和多周期取最大值；单周期做一个求和

|      | pipelined | singlecycle | multicycle |
| ---- | --------- | ----------- | ---------- |
| a.   | 500ps     | 1650ps      | 500ps      |
| b.   | 200ps     | 800ps       | 200ps      |

---

> **4.12.2** [10] <4.5> What is the total latency(等待时间) of an LW instruction in a pipelined  and non-pipelined processor?
>
> <font color=green>Answer :</font>
>
> 等待时间 (*latency*) = 执行一个任务的总时间，即指令周期

|      | pipelined | singlecycle | multicycle |
| ---- | --------- | ----------- | ---------- |
| a.   | 2500ps    | 1650ps      | 2500ps     |
| b.   | 1000ps    | 800ps       | 1000ps     |

---

> **4.12.3** [10] <4.5> If we can split one stage of the pipelined datapath into two new  stages, each with half the latency of the original stage, which stage would you split  and what is the new clock cycle time of the processor?

> <font color=green>Answer :</font>
>
> 目的实际上是降低 *clock cycle*，所以要分开的是原来最长的那个阶段

|      | stage to split | new clock cycle time |
| ---- | -------------- | -------------------- |
| a.   | MEM            | 400ps                |
| b.   | IF             | 190ps                |

---

##### The remaining problems in this exercise assume that instructions executed by the  processor are broken down as follows:

|      | ALU  | beq  | lw   | sw   |
| ---- | ---- | ---- | ---- | ---- |
| a.   | 50%  | 25%  | 15%  | 10%  |
| b.   | 30%  | 25%  | 30%  | 15%  |

---

> **4.12.4** [10] <4.5> Assuming there are no stalls or hazards, what is the utilization  of the data memory?
>
> <font color=green>Answer :</font>
>
> 只有 `lw` 和 `sw` 指令会用到内存

|      | utilization |
| ---- | ----------- |
| a.   | 25%         |
| b.   | 45%         |

---

> **4.12.5** [10] <4.5> Assuming there are no stalls or hazards, what is the utilization  of the write-register port of the “Registers” unit?
>
> <font color=green>Answer :</font>
>
> 只有`ALU` 和 `lw` 指令会用到寄存器组的 “写” 端口



|      | utilization |
| ---- | ----------- |
| a.   | 65%         |
| b.   | 60%         |

---

> **4.12.6** [30] <4.5> Instead of a single-cycle organization, we can use a multi-cycle organization where each instruction takes multiple cycles but one instruction  finishes  before  another  is  fetched.  In  this  organization,  an  instruction  only  goes  through stages it actually needs (e.g., ST only takes 4 cycles because it does not need  the WB stage). Compare clock cycle times and execution times with single-cycle,  multi-cycle, and pipelined organization.

> <font color=green>Answer :</font>
>
> <font color=deeppink>多周期计算时注意各指令所用步骤</font>
>
> 不妨设总指令数为 $n\,(n为20的倍数)$，对于时钟周期数，流水线为 $n+4$（假设没有阻塞和冒险），多周期为$3*$(`beq`指令所占比例) $+4*$(`ALU`和`sw`指令所占比例)$*n+5*$(`lw`指令所占比例)$*n$，单周期为 $n$
>
> 执行时间...就是直接算（周期时长$*$周期数）

<font color=green>下面这个表格里面，执行时间部分以**流水线的**为基准（单位 1），且单周期执行时间的比值取 n 比较大的时候</font>

<table>
    <tr>
        <th colspan="2"> </th>
        <th>pipelined</th>
        <th>multicycled</th>
        <th>singlecycled</th>
    </tr>
    <tr>
        <td rowspan="2">a.</td>
        <td>clock cycle times</td>
        <td>n+4</td>
        <td>3*25%*n+4*60%*n+5*15%*n</td>
        <td>n</td>
    </tr>
    <tr>
        <td>execution times</td>
        <td>1</td>
        <td>3*0.25+4*0.6+5*0.15=3.9(times)</td>
        <td>1650ps/500ps=3.3(times)</td>
    </tr>
    <tr>
        <td rowspan="2">b.</td>
        <td>clock cycle times</td>
        <td>n+4</td>
        <td>3*25%*n+4*45%*n+5*30%*n</td>
        <td>n</td>
    </tr>
    <tr>
        <td>execution times</td>
        <td>1</td>
        <td>0.25*3+0.45*4+0.3*5=4.05(times)</td>
        <td>800ps/200ps=4(times)</td>
    </tr>
</table>



### Exercise 4.13

##### In this exercise, we examine how data dependences affect execution in the basic five-stage pipeline described in Section 4.5. Problems in this exercise refer to the following sequence of instructions:

![Screenshot 2020-04-14 at 2.45.49 PM](/Users/lapland/Library/Application Support/typora-user-images/Screenshot 2020-04-14 at 2.45.49 PM.png)

> **4.13.1** [10] <4.5> Indicate dependences and their type.

> <font color=green>Answer :</font>
>
> 将指令顺序标号为 $1,2,3$，对于各个寄存器的使用时间如下图所示

![Screenshot 2020-04-14 at 7.36.06 PM](/Users/lapland/Library/Application Support/typora-user-images/Screenshot 2020-04-14 at 9.33.06 PM.png)

故存在的相关有：（均为数据相关）

<table>
    <tr>
        <th> </th>
        <th>dependences</th>
    </tr>
    <tr>
        <td rowspan="2">a.</td>
        <td>RAW on $1 from Ins1 to Ins3</td>
    </tr>
    <tr>
        <td>RAW on $6 from Ins2 to Ins3</td>
    </tr>
    <tr>
        <td rowspan="2">b.</td>
        <td>RAW on $1 from Ins1 to Ins2</td>
    </tr>
    <tr>
        <td>RAW on $1 from Ins1 to Ins3</td>
    </tr>
</table>
---

>**4.13.2** [10] <4.5> Assume there is no forwarding (数据定向) in this pipelined processor. Indicate hazards and add `nop` instructions to eliminate them.

> <font color=green>Answer :</font>
>
> 注意点是在同一个时钟周期内，可以对同一个寄存器**先写后读**

<p align="center">a.</p>

```assembly
lw $1,40($6)
add $6,$2,$2
nop
nop # 在流水线中，R-type 指令在 WB 段写回，故需延迟两个周期
sw $6,50($1)
```

<p align="center">b.</p>

```assembly
lw $5,–16($5)
nop
nop # sw 指令的 ID 段至少要和 lw 指令的 WB 段在同一个时钟周期内，故延迟两个周期
sw $5,–16($5)
add $5,$5,$5
```

---

> **4.13.3** [10]<4.5>Assume there is full forwarding. Indicate hazards and add `nop` instructions to eliminate them.

> <font color=green>Answer :</font>
>
> 由于 *forwarding* 技术的存在，在代码段`a.`中的`$1`便解决了冲突；可是 *forwarding* 并不能使`lw`指令的输出数据传送到*紧随其后的*指令的 EX 段（来替代 ID 段的作用）（不过可以传到*间隔一条的*指令），故在`b.`代码段中仍然需要一个周期的 stall；而在`a.`中，由于`add`指令<font color=orange>已经在 EX 段结束了运算</font>，故可以利用<font color=orange>从 MEM 到 EX </font>的 *forwarding* 来处理数据冲突的问题，如下：

<p align="center">a.</p>

```assembly
lw $1,40($6)
add $6,$2,$2
sw $6,50($1)
```

<p align="center">b.</p>

```assembly
lw $5,–16($5)
nop
nop
sw $5,–16($5)
add $5,$5,$5
```

---

##### The remaining problems in this exercise assume the following clock cycle times:

|      | Without forwarding | With full forwarding | With ALU-ALU forwarding only |
| ---- | ------------------ | -------------------- | ---------------------------- |
| a.   | 300ps              | 400ps                | 360ps                        |
| b.   | 200ps              | 250ps                | 220ps                        |

> **4.13.4** [10] <4.5> What is the total execution time of this instruction sequence without forwarding and with full forwarding? What is the speed-up achieved by adding full forwarding to a pipeline that had no forwarding?

> <font color=green>Answer :</font>
>
> 总执行时间 = 时钟周期数 $*$ 周期时长
>
> 每一个 stall 就是顺延一个周期

|      | No forwarding        | With full forwarding | Speed-up rate                 |
| ---- | -------------------- | -------------------- | ----------------------------- |
| a.   | $(7+1)*300ps=2400ps$ | $7*400ps=2800ps$     | $\frac{2400ps}{2800ps}=0.857$ |
| b.   | $(7+2)*200ps=1800ps$ | $(7+2)*250ps=2250ps$ | $\frac{1800ps}{2250ps}=0.8$   |

---

> **4.13.5** [10] <4.5> Add nop instructions to this code to eliminate hazards if there is ALU-ALU forwarding only (no forwarding from the MEM to the EX stage)?

> <font color=green>Answer :</font>
>
> 由于不允许 MEM 到 EX 的数据定向，故在`a.`中，关于`$6`的冲突便需要一个 stall 来解决

<p align="center">a.</p>

```assembly
lw $1,40($6)
add $6,$2,$2
nop
sw $6,50($1)
```

<p align="center">b.</p>

```assembly
lw $5,–16($5)
nop
nop
sw $5,–16($5)
add $5,$5,$5
```

---

> **4.13.6** [10] <4.5> What is the total execution time of this instruction sequence with only ALU-ALU forwarding? What is the speed-up over a no-forwarding pipeline?

|      | No forwarding        | With only ALU-ALU forwarding | Speed-up rate                |
| ---- | -------------------- | ---------------------------- | ---------------------------- |
| a.   | $(7+1)*300ps=2400ps$ | $(7+1)*360ps=2880ps$         | $\frac{2400ps}{2880ps}=0.83$ |
| b.   | $(7+2)*200ps=1800ps$ | $(7+2)*220ps=1980ps$         | $\frac{1800ps}{1980ps}=0.91$ |

### Exercise 4.16

##### The first three problems in this exercise refer to the following MIPS instruction:

|      | Instruction      |
| ---- | ---------------- |
| a.   | `lw $1, 40($6)`  |
| b.   | `add $5, $5, $5` |

> **4.16.1** [5]<4.6>As this instruction executes, what is kept in each register located between two pipeline stages?

> <font color=green>Answer :</font>
>
> 段间寄存器用来存储控制信号和防止被冲掉的数据

| 寄存器 | 存储的内容 |
| ------ | ---------- |
|        |            |
|        |            |
|        |            |
|        |            |

